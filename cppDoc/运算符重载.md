### 1.2输入和输出运算符

​         IO库定义了用其读写内置内置类型的版本，而类则需要自定义适合其对象的新版本一支持IO操作。

#### 1.2.1 重载输出运算符<<

​        通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个ostream对象。

​       第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参，而之所以该形参可以是常量是因为打印对象不会改变对象的内容。

> 通常，输出运算符应该主要负责打印对象的内容而非格式控制，输出运算符而应该打印换行符。

**输入输出运算符必须是非成员函数**

​       与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。因此，如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数。当然，IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友员。

#### 1.2.2 重载输入运算符>>

​       通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。

> 输入运算符必须处理输入可能失败的情况，而输出运算符则不需要。

**输入时的错误**

​       在执行输入运算符是可能发生下列错误：

1. 当流含有错误类型的数据时读取操作可能失败。
2. 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。

​       通常将对象置为合法的状态，我们能保护使用者免于受到输入错误的影响。此时的对象处于可用的状态，即它的成员都是被正确定义的。而且该对象也不会产生误导性的结果，因为它的数据在本质上确实是正确的。

> 当读取操作发生错误时，输入运算符应该负责从错误中恢复。

### 1.3 算符和关系运算符

​        通常情况下，我们把算符和关系运算符定义成非成员函数以允许对左侧或右侧的运算符进行转行。因为这些运算符一般不需要改变运算符对象的状态，所以形参都是常量的引用。

​        算符运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果。如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符。

> 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。

#### 1.3.1 相等运算符

​         通常情况下，C++中的类通过定义相等运算符来检验两个对象是否相等。也就是说，它们会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等。

​         设计相等运算符的准则：

* 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成`operator==`而非一个普通的命名函数。

* 如果类定义了`operator==`，则该运算符应该能判断一组给定的对象中是否含有重复数据。

* 通常情况下，相等运算符因该具有传递性。

* 如果类定义了`operator==`，则这个类也应该定义`operator!=`运算符，反之亦然。

* 相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符因该负责实际比较对象的工作，而另一个运算符则只调用那个真正工作的运算符。

#### 1.3.2 关系运算符

​        定义了相等运算符的类也常常包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义`operator<`会比较有用。

​       定义关系运算赋的准则：

* 定义顺序关系，令其与关联容器中对关键字的要求一致。

* 如果类同时也含有==运算符的话，则定义一种关系与==保持一致。特别是，如果两个对象是!=的，那么一个对象应该<另外一个。

  > 如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果类同时还包含==，则当且仅当<的定义和==产生的结果一致时才定义<运算符。

### 1.4 赋值运算符

​           为了与内置类型的赋值运算符保持一致，这个新的赋值运算符将返回其左侧对象的引用。和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也必须先时方当前内存空间，再创建一片新空间。

> 我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。

**复合赋值运算符**

​        复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算符都定义在类的内部。为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要返回其左侧运算对象的引用。

> 赋值运算符必须定义为类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。

#### 1.5 下标运算符

​         为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。进一步，我们最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对像赋值。

> 如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通应用，另一个是类的常量成员并且返回常量引用。

如，

```C++
class StrVec{
    public:
      std::string& operator[](std::size_t n){
          return elements[n];
      }
      const std::string& operator[](std::size_t n) const{
          return elements[n];
      }
    private:
      std::string *elements;
};
```

#### 1.6 递增和递减运算符

​        在迭代器中通常会实现递增运算符(++)和递减运算符(--)，这两种运算符使得类可以在元素的序列中前后移动。C++语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。

> 定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。

**定义前置递增/递减运算符**

```C++
class StrBlobPtr{
    public:
    StrBlobPtr& operator++();
    StrBlobPtr& operator--();
};
```

> 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。

**区分前置和后置运算符**

​        要想同时定义前置和后置运算符，必须首先解决一个问题，即普通的重载形式无法区分这两种情况。为了解决这个问题，后置版本接受一个额外的int类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。

```C++
class StrBlobPtr{
    public:
      StrBlobPtr operator++(int);
      StrBlobPtr operator--(int);
};
```

为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前的值)，返回的形式时一个值为非引用。

### 1.7 成员访问运算符

​        在迭代器类及智能指针类中常常用到解引用运算符(*)和箭头运算符(->)。如，

```C++
class StrBlobPtr{
    public:
    std::string& operator*() const {
        auto p = check(curr, "dereference pass end");
        return (*p)[curr];
    }
    std::string* operator->() const{
        return &this->operator*();
    }
};
```

解引用运算符首先检查curr是否仍在作用域范围内，如果是，则返回curr所指元素的一个引用。箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址。

> 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。

​       值得注意的是，我们将这两个运算符定义成const成员，这是因为与递增和递减运算符不一样，获取一个元素并不会改变StrBlobPtr对象的状态。同时，它们的返回值分别是非常量string的引用或指针，因为一个StrBlobPtr只能绑定到非常量的StrBlob对象。

**对箭头运算符返回值的限定**

​        箭头运算符永远不能丢掉成员访问这个最基本的含义。当我们重载箭头时，可以改变的是箭头从哪个对像中获取成员，而箭头获取成员这一事实则永远不变。

​       对于形如point->mem的表达式老说，point必须是指向类对象的指针或者是一个重载了operator->的类的对象。根据point类型的不同，point->mem分别等价于

```C++
(*point).mem;           // point是一个内置的指针类型
point.operator->mem();  // point是类的一个对象
```

除此之外，代码都将发生错误。point->mem的执行过程如下所示：

1. 如果point是指针，则我们应用内置的箭头运算符，表达式等价于(*point).mem。首先解引用该指针，然后从得到的对象中获取指定的成员。如果point所指的类型没有名为mem的成员，成员会发生错误。

2. 如果point是定义了operator->的类的一个对象，则我们使用point.operator->()的结果来获取mem。其中，如果该结果是一个指针，则执行第1步；如果该结果本身含有重载的operator->()，则重符调用当前步骤，最终，当这一过程结束时程序或者返回了所需要的内容，或者返回一些表示程序错误的信息。

   > 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。

### 函数调用运算符

​      如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。如，

```C++
struct absInt(){
    int operator()(int val) const{
        return val < 0 ? -val : val;
    }
};

int i = -42;
absInt absObj;
int ui = absObj(i); // 将i传递给absObj.operator()
```

> 函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互只见应该在参数的数量或类型上有所区别。

​      如果类定义了调用运算符，则该类的对象称作**函数对象**。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。

