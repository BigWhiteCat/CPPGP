### 1.1 OOP: 概述

​        **面向对象程序设计**的核心思想是数据抽象、继承和动态绑定。

1. 通过使用数据抽象，我们可以将类的接口和实现分离。

2. 使用继承，可以定义相似的类型并对其相似关系建模。

3. 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。



​       对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为**虚函数**。

> 在C++语言中，当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定。

> 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

> 在派生类对象中含有与基类对应的组成部分，这一事实是继承的关键所在。

**派生类构造函数**

​        尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。

> 每个类控制它自己的成员初始化过程。

​      除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分。

> 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

**派生类使用基类的成员**

派生类可以访问基类的公有成员和受保护成员。

**继承与静态成员**

​        如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。

```C++
class Base{
    public:
      static void statmem();
};

class Deirved : public Base{
    void f(const Derived &);
};
```

静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某个静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它：

```C++
void Derived::f(const Derived &derived_obj){
    Base::statmem();
    derived_obj.statmem();
    statmem();
}
```

**派生类的声明**

​      派生类的声明于其他类差别不大，声明中包含类名但是不包含它的派生列表。

```C++
class Bulk_quote : public Quote; // 错误
class Bulk_quote;  // 正确
```

**被用作基类的类**

​     如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。

```C++
class Quote; 
class Bulk_quote : public Quote {
    ...
};  // 错误
```

**防止继承的发生**

​      有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否合适作为一个基类。为了实现这一目的，我们可以在类名后跟一个关键字`final`:

```C++
class NoDerived final {....}; // NoDerived不能用作基类
class Base{...};
class Last final : public Base {....}; // Last不能作为基类
```

#### 1.2.3 类型转换与继承

> 理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。

​       我们可以将基类的指针或引用绑定到派生类对象中。可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的指针或引用时，实际上我们并不清楚该应用或指针所绑定对像的真实类型。该对象可能是基类的地像，也可能是派生类的对象。

> 和内置指针一样，智能指针也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。

**静态类型和动态类型**

​    当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示的动态类型区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。

> 基类的指针或引用的静态类型可能与其动态类型不一致，我们一定要理解其中的缘由。

**不存在从基类向派生类的隐式类型转化**

**在对象之间不存在类型转换**

​        派生类向基类的自动类型转换只对指针或引用类型有效，在派生类型和基类类型之间不存在这样的转换。

> 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

### 1.3 虚函数

​        通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被调用到了，这是因为编译器也无法确定到底会使用哪个虚函数。

**对虚函数的调用可能在运行时才被解析**

​        当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。

​        当我们通过一个具有普通类型(非引用非指针)的表达式调用虚函数时，在编译时就会将调用的版本确定下来。**派生类中的虚函数**

​        当我们在派生类中覆盖了某个虚函数时，可以再一次使用`virtual`关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。

​        一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。同样，派生类中虚函数的返回类型也必须与基类函数匹配。

> 基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。

**final和override说明符**

​       派生类如果定义了一个函数与基类中虚函数的名字相同但是形参不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中的原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。就实际编程习惯而言，这种神明往往意味着发生了错误，因为我们可能原本希望派生类能覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。

​        要想调试并发现这样的错误显然非常困难。在C++11标准中，我们可以使用`override`关键字来说明派生类中的虚函数。这么做的好处是在使的程序员的意图更加清晰的同时让编译器可以为我们发现一些错误，后者在编程实践中更加重要。

​         我们还能把某个函数指定为`final`，如果我们已经把函数定义成`final`了，则之后任何尝试覆盖该函数的操作都将引发错误。

**虚函数与默认实参**

​        和其他函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参由本次调用的静态类型决定。

> 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

**回避虚函数的机制**

​       在某些情况下，我们希望对虚函数的调用不用进行动态绑定，而是强迫其执行虚函数的某个版本。使用作用域运算符可以实现这一目的，如

```C++
double undiscounted = base->Quote::net_price(42); 
```

> 通常情况下，只有成员函数(或友员)中的代码才需要使用作用域运算符来回避虚函数的机制。

​       什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。

> 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。

### 1.4 抽象基类

**纯虚函数**

​       我们通过在函数体的位置书写`=0`就可以将一个虚函数说明为纯虚函数。其中，`=0`只能出现在类内部的虚函数声明语句处，如

```C++
class Disc_quote : public Quote{
    public:
      Disc_quote() = default;
      Disc_quote(const std::string &book, double price, std::size_t qty, double disc):                    quantity(qty), discount(disc) { }
      double net_price(std::size_t ) const = 0; // 纯虚函数
    protected:
      std::size_t quantity = 0;
      double discount = 0.0;
};
```

​        值的注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个`=0`的函数提供函数体。

**含有纯虚函数的类是抽象基类**

​      含有纯虚函数的类是**抽象基类**。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能创建一个抽象基类的对象。

> 我们不能创建抽象基类的对象。

**派生类构造函数只初始化它的直接基类**

​      每个类控制其对象的初始化过程。因此，即使派生类没有自己的数据成员，它也仍然需要像原来一样提供一个接受参数的构造函数。该构造函数将其参数传递给其基类。

### 1.5 访问控制与继承

​     每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对象对于派生类来说是否**可访问**。

**受保护的成员**

`protected`说明符可以看作是`public`和`private`中和后的产物：

* 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。

* 和公有成员类似，受保护的成员对于派生类的成员和友员来说是可以访问的。

* 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访特权。如，

```C++
class Base{
    protected:
      int prot_mem;
};

class Sneaky: public Base{
    friend void clobber(Sneaky &);
    friend void clobber(Base &);
    int j;
};

// 正确
void clobber(Sneaky &s){
    s.j = s.prot_mem = 0;
}

// 错误
void clobber(Base &b){
    b.prot_mem = 0;
}
```

​        派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。

**公有、私有和受保护继承**

​       某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。

​       派生访问说明符对于派生类的成员及友员能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。

​      派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限。

​      派生访问说明符还可以控制继承自派生类的新类的访问权限。

**友元与继承**

​        就像友元不能传递一样，友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。

> 不能继承友元关系，每个类负责控制各自成员的访问权限。

**默认的继承保护级别**

​        默认情况下，使用`class`关键字定义的派生类是私有的继承的，而使用struct关键字定义的派生类是公有继承的。`struct`和`class`关键字的唯一差别就是默认成员访问访问说明符及默认派生访问说明符，除此之外，再无其他不同之处。

### 1.6 继承中的类的作用域

​        每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域欠套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。

### 1.7 构造函数与拷贝控制

    #### 1.7.1 虚析构函数

​        继承关系对基类拷贝控制最直接的影响时基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。

​       当我们delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如，如果我们delete一个Quote*类型的指针，则该指针有可能实际指向了一个Bulk_quote的析构函数。如果这样的话，编译器就必须清楚它应该执行的是Bulk_quote的析构函数。和其他函数一样，我们通过在基类中将析构函数定义为虚函数以确保执行正确的析构函数版本。

​       和其他虚函数一样，析构函数的虚属性也会被继承。因此，派生类和基类的析构函数都将是虚析构函数。

> 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。

​       之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法由此推断该基类还需要赋值运算符或者拷贝构造函数。

**虚析构函数将阻止合成移动操作**

​       基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响；如果一个类定义了析构函数，即使它通过`=default`的形式时用了合成的版本，编译器也不会为这个类合成移动操作。

#### 1.7.2 合成拷贝控制与继承

