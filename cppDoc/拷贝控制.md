​        当定义一个类时，我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：**拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。**拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了一个独享赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为**拷贝控制操作。**如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。

### 1.1 拷贝、赋值与销毁

#### 1.1.1 拷贝构造函数

​        如果一个构造函数的第一个参数时自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。拷贝构造函数的第一个参数必须是一个引用类型。

**合成拷贝构造函数**

​        如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个，即使我们定义了其它的构造函数，编译器也会为我们合成一个拷贝构造函数。

​        每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数拷贝，内置类型的成员则直接拷贝。

**拷贝初始化发生的位置**

​        拷贝初始化不仅在我们使用=定义变量是会发生，在下列情况下也会发生

* 将一个对象作为实参传递给一个非引用类型的形参

* 从一个返回类型为非引用类型的函数返回一个对象
* 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

#### 1.1.2 拷贝赋值运算符

​         与类控制其对象如何初始化一样，类也可以控制其对象如何赋值，与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

**重载赋值运算符**

​        重载运算符本质上是函数，其名字由`operator`关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为`operator=`的函数。

> 赋值运算符通常应该返回一个指向其左侧运算对象的引用。

#### 1.1.3析构函数

​         析构函数执行与构造函数相反的操作，构造函数初始化对象的非`static`数据成员，还可能做一些其他动作；析构函数释放对象使用的资源，并销毁对象的非`static`数据成员。

**析构函数完成什么工作**

​        如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

​        在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么与不需要做。

> 隐式销毁一个内置指针类型的成员不会delete它所指向的对象。

什么时候会调用析构函数

* 变量在离开其作用域时被销毁。
* 当一个被销毁时，其成员被销毁。
* 容器被销毁时，其元素被销毁。
* 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。
* 对于临时对象，当创建它的完整表达式结束时被销毁。

> 当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

**合成析构函数**

​        当一个类未定义自己的析构函数时，编译器会为它定义一个**合成析构函数。**认识到析构函数体自身并不直接销毁成员时非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。

#### 1.1.4 三/五法则

**需要析构函数的类也需要拷贝和赋值操作**

​       当我们决定为一个类是否需要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需要要比对拷贝构造函数或赋值运算符的需要更为明显。如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。

**需要拷贝操作的类也需要赋值操作，反之亦然**

​        如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然，如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。

#### 1.1.5 使用=default

​        我们可以通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本。当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的(就像其它的函数一样)。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像拷贝赋值运算符所做的那样。

#### 1.1.6 阻止拷贝

> 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显示地。

​          虽然大多数类应该定义拷贝构造函数和拷贝赋值运算符，但是对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。

**定义删除的函数**

​         在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的。

```C++
struct NoCopy{
    NoCopy() = default; // 合成构造
    NoCopy(const NoCopy &) = delete; // 阻止拷贝
    NoCopy &operator=(const NoCopy &) = delete; // 阻止赋值
    ~NoCopy() = default; // 合成析构
    ...
};
```

​        与=default不同，=delete必须出现在函数第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的。一个默认的成员只影响为这个成员而生成的代码，因此=default直到编译器生成代码时才需要。而另一方面，编译器需要知道一个函数是删除的，以便阻止试图使用它的操作。

​        与=default的另一个不用之处是，我们可以对任何函数指定=delete(我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default)。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。

**合成的拷贝控制成员可能是删除的**

​        对某些类来说，编译器将这些合成的成员定义为删除的函数：

* 如果类的某个成员的析构函数是删除的或不可访问的，(例如是private的)，则类的合成析构函数被定义为删除的。

* 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。

* 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。

* 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且类型未显示定义未默认构造函数，则该类的默认构造函数被定义未删除的。

  > 本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数被定义为删除的。

**private 拷贝控制**

​         在C++11标准之前，类是同年过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝：

```C++
class PrivateCopy {
    private:
      PrivateCopy(const PrivateCopy &);
      PrivateCopy &operator=(const PrivateCopy &);
    
    public:
      PrivateCopy() = default;
      ~PrivateCopy();
};
```

​        由于析构函数是public的，用户可以定义PrivateCopy类型的对象。但是，由于拷贝构造函数和拷贝赋值运算符是private的，用户代码不能拷贝这个类型的对象。但是，友员和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为private的，但并不定义它们。

​        声明但不定义一个成员函数是合法的。试图访问一个未定义的成员将导致一个链接时错误。通过声明(但不定义)private的拷贝构造函数，我们预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记未错误；成员函数或是友员函数中的拷贝操作将会导致链接时错误。

> 希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造和拷贝赋值运算符，而不应该将它们声明为private的。

### 1.6 对象移动

​         在某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。

> 标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。

#### 1.6.1 右值引用

​        为了支持移动操作，C++11引入了一种新的引用类型----**右值引用**。所谓右值引用就是必须绑定到右值的引用。我们通过&&而不是&来获得右值引用。如我们将要看到的，右值引用有一个重要的性质-----只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源"移动"到另一个对象中。

​        一般而言，一个做值表达式表示的是一个对象的身份，另一个右值表达式表示的是对象的值。

​       类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。如我们所知，对于左值引用，我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性；我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用绑定到一个左值上：

```	C++
int i = 42; 
int &r = i; // 正确
int &&r = i; // 错误
int &r2 = i * 42; // 错误
const int &r3 = i * 42; // 正确
int &&rr2 = i *42; // 正确
```

​        返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。

​        返回非引用类型的参数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个const的左值引用或者一个右值引用绑定到这类表达式上。

**左值持久，右值短暂**

​       考察左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面长量，要么是在表达式求值过程中创建的临时对象。

​       由于右值引用只能绑定到临时对象上，我们得知：

* 所引用的对象将要被销毁
* 该对象没有其它用户

这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。

> 右值引用指向将要被销毁的对象，因此，我们可以从绑定的右值引用的对象"窃取"状态-----偷值。

**变量是左值**

变量可以看作是只有一个运算对象而没有运算符的表达式，虽然我们很少这样开带变量。

> 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。

**标准库move函数**

​        虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显示地将一个左值转换为右值类型。我们还可以通过调用一个名为**move**的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件`utility`中。如，

```C++
int &&rr3 = std::move(rr1);
```

move调用告诉编译器，我们有一个左值，但我们希望像右值值一样处理它。调用move就意味着承诺：除了对rr1赋值或者销毁它外，我们将不再使用它。

> 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。

> 使用move的源代码，我们不提供using声明。我们直接调用std::move而不是move.

#### 1.6.2 移动构造函数和移动赋值运算符

​        类似string类，如果我们自己的类也同时支持移动和拷贝，那么也能从中受益。为了让我们自己的类支持移动操作，需要为其定义移动构造函数和移动赋值运算符。

​        类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用，其他的参数都必须有默认值。

​        除了完成资源移动，移动构造函数还必须保证移后源对象处于这样一个状态----**销毁它是无害的，特别是，一旦资源完成移动，源对象必须不再指向被移动的资源----这些资源的所有权已经归属新创建的对象。**例如,

```c++
StrVec::StrVec(StrVec &&s) noexcept: elements(s.elements), first_free(s.first_free), cap(s.cap){
    s.elements = s.first_free = s.cap = nullptr;
}
```

​        与拷贝构造函数不同，移动构造函数不分配任何新的内存。它接管给定的StrVec中的内存。在接管内存之后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。

